/*=====================================================================
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  ---------------------------------------------------------------------
  Purpose : Use MQ2 gas sensor module and read analog values. The code
            also includes calibration. Since the mapping betweeen Rs
            and PPM is non-linear no conversion to PPM is done at the
            moment. No compensation has been included for current
            humidity and temperature.
  Date    : 10 Feb 2016
  Boards  : ArduinoUno, LaunchPadF5529
  =====================================================================
*/

// Comment/uncomment as suitable for your hardware
// #define LaunchPadF5529

#ifdef LaunchPadF5529
#define VREF 3300L // mV
#define AIN A5 // aka P6_5
#define ADC_MAX 4095
#else
#define VREF 5000L // mV
#define AIN A5 // aka 19
#define ADC_MAX 1023
#endif

// Application can be SMOKE, LPG, PROPANE
#define SMOKE

unsigned long Rs_clean;

typedef struct {
  float ppm;
  float rsByRo;
} Map;

// Following values are obtained from datasheet
#if defined(SMOKE)
Map ppmData[] = {
  {196.383469184, 3.3397668609},
  {212.3776035308, 3.2732173919},
  {232.8892319004, 3.0265443929},
  {253.0568305969, 2.9736932787},
  {276.0756646852, 2.8804998324},
  {300.9945497196, 2.7188881798},
  {324.0822540963, 2.6429638713},
  {351.7315985925, 2.6403981005},
  {380.8961161044, 2.5670645056},
  {412.4788669655, 2.482229822},
  {446.6803637518, 2.406267552},
  {485.5944658995, 2.3354344686},
  {525.6839779223, 2.3095066951},
  {567.2602295611, 2.2101873656},
  {612.1247394936, 2.146912865},
  {665.2312663982, 2.0966723749},
  {720.3902256614, 2.025867246},
  {783.149507471, 1.9519207418},
  {825.9139695897, 1.9064916263},
  {892.8583079225, 1.8797583207},
  {970.8728877758, 1.8293490584},
  {1044.7488078276, 1.7896774139},
  {1131.3762107204, 1.7349089321},
  {1225.1864951592, 1.6854140163},
  {1326.7752438994, 1.6303488235},
  {1445.899692617, 1.5699433795},
  {1546.115837429, 1.5379536148},
  {1684.9337703336, 1.5026162785},
  {1824.643368925, 1.4523944166},
  {1983.60347598, 1.3897824791},
  {2139.7759895388, 1.3506188978},
  {2317.1997256153, 1.3019317609},
  {2509.334899841, 1.2586618416},
  {2646.1963481594, 1.2150585004},
  {2846.6514489446, 1.1725019432},
  {3103.2186923919, 1.174333602},
  {3330.9156460733, 1.1221490708},
  {3591.1772378523, 1.0801230441},
  {3906.1952839837, 1.0246622554},
  {4145.3674962885, 1.0016090043},
  {4460.7979111212, 0.9878896824},
  {4798.0884450277, 0.9230186546},
  {5185.1217583048, 0.8962080889},
  {5615.0563303662, 0.8786938408},
  {6056.2256139457, 0.840498359},
  {6655.1388691682, 0.7994769874},
  {7138.7156103371, 0.7543183205},
  {7670.9971477937, 0.7496348497},
  {7982.6925049631, 0.707300803},
  {8362.3802089096, 0.6583763431},
  {9004.9010645624, 0.6554529743},
  {9398.73652597, 0.6085653439},
  {10295.8382737189, 0.6105816088}
};
#elif defined(LPG)
Map ppmData[] = {
  {195.1719516541, 1.6090322212},
  {211.9608025561, 1.5739295945},
  {229.5818949308, 1.518293349},
  {248.6678944617, 1.4671764561},
  {269.3405843463, 1.4161355585},
  {291.731872074, 1.3676639418},
  {315.9846310959, 1.3185533139},
  {342.253612466, 1.2719442685},
  {370.706432271, 1.2284080444},
  {401.5246411482, 1.1849855103},
  {434.9048827168, 1.1444257184},
  {471.0601483139, 1.0956272215},
  {531.4774496419, 1.0399716119},
  {577.7079567007, 1.0031434973},
  {625.7349746581, 0.9710598401},
  {677.7546578146, 0.9367342109},
  {734.0989313253, 0.9036219454},
  {795.127314522, 0.8650268003},
  {861.2292149201, 0.8506861384},
  {932.8264129347, 0.8097326709},
  {990.090214036, 0.7772330769},
  {1065.6247599105, 0.7636256723},
  {1154.2141222112, 0.7370602653},
  {1250.1682487405, 0.7139010502},
  {1354.0993998277, 0.6898659034},
  {1466.6707352878, 0.6566545937},
  {1588.6005458857, 0.6456934217},
  {1720.6668365774, 0.6221463663},
  {1863.7122907738, 0.5891095465},
  {2018.6496473021, 0.5682853347},
  {2186.4675243737, 0.5494715348},
  {2368.2367277204, 0.5269806657},
  {2565.1170831501, 0.5068793718},
  {2778.3648371175, 0.4869791551},
  {2956.4070262041, 0.4629729099},
  {3202.1841731003, 0.45579762},
  {3468.3936912502, 0.4373948111},
  {3756.7341999125, 0.4197350148},
  {4069.0455309025, 0.4048979596},
  {4407.3204681191, 0.3885502222},
  {4773.7174630222, 0.3713505757},
  {5024.453305185, 0.3548172225},
  {5405.1358648695, 0.350408837},
  {5854.4849767067, 0.3364563383},
  {6341.1901568014, 0.323059397},
  {6868.3569544889, 0.310015888},
  {7439.3490950084, 0.2997524226},
  {8057.8099426285, 0.2898287421},
  {8727.6857480834, 0.279259309},
  {9453.2508286552, 0.2672075837},
  {10024.7602069181, 0.254696059},
  {10422.4637058312, 0.255824416}
};
#elif defined(PROPANE)
Map ppmData[] = {
  {199.1959954936, 1.7151207359},
  {218.1622680796, 1.637653397},
  {234.9920895865, 1.5798792306},
  {255.376194326, 1.5156517247},
  {277.220844884, 1.4646237682},
  {299.601906451, 1.411212078},
  {324.5089307949, 1.3637003263},
  {350.318963898, 1.3107315909},
  {380.7069589361, 1.2543476206},
  {412.3565489085, 1.2051016049},
  {445.1536005999, 1.1661355616},
  {486.8437558665, 1.1170479948},
  {520.5098658582, 1.0552563147},
  {523.9853430572, 1.0831834925},
  {567.5461996952, 1.0314861642},
  {614.7284328777, 1.006059149},
  {665.8331011489, 0.974353437},
  {717.9937775535, 0.9400705249},
  {786.7058784117, 0.9224354458},
  {847.3325409246, 0.888538284},
  {916.4181997076, 0.8613066313},
  {988.2094535275, 0.8341829353},
  {1075.1222934596, 0.7985304657},
  {1165.9782722545, 0.7685807964},
  {1261.3105526088, 0.7448016471},
  {1366.1680049902, 0.7184739336},
  {1479.7426486273, 0.6946879515},
  {1612.9496777842, 0.6714666776},
  {1736.0025266083, 0.6479461369},
  {1880.3228939368, 0.6167529155},
  {2032.1282982984, 0.6014185028},
  {2200.3693015105, 0.5727797784},
  {2389.3439773076, 0.5494715348},
  {2595.6449059385, 0.5297408895},
  {2803.1274123174, 0.513393787},
  {3036.1618530015, 0.5004476175},
  {3259.5183909512, 0.4827975161},
  {3625.7362640361, 0.4605848858},
  {3927.1572478433, 0.4456598869},
  {4253.6364826823, 0.4283496024},
  {4663.8127392005, 0.4072550641},
  {5034.7521795752, 0.391493304},
  {5405.1358648695, 0.3782500309},
  {5906.6639139564, 0.3611467882},
  {6397.7069237922, 0.3475728003},
  {6898.8966663984, 0.3348003819},
  {7597.7877048951, 0.3206773042},
  {8183.9083574088, 0.3103760006},
  {8883.9525363021, 0.2987102729},
  {9643.8778662299, 0.2860473337},
  {10193.8087201062, 0.2810481007}
};
#endif

unsigned long averager(int pin, unsigned int numSamples) {
  unsigned long sum = 0L;
  for(int i = 0; i < numSamples; i++) {
    sum += analogRead(pin);
    delay(50);
  }
  return sum/numSamples;
}

void calibrate() {
  Serial.println("Calibrating ...");
  unsigned long voltage = VREF*averager(AIN, 100)/(ADC_MAX+1);
  Rs_clean = 100L*(VREF-voltage)/voltage;
  Serial.print("Calibrated Rs_clean: ");
  Serial.println(Rs_clean);
}

float getPPM(float rsByRo) {
  int maxIndex = sizeof(ppmData)/sizeof(Map)-1;
  for (int i=maxIndex; i>=0; i--) {
    if (rsByRo < ppmData[i].rsByRo) {
      if (i<maxIndex) // do a linear interpolation between available data points
        return map(100*rsByRo, 100*ppmData[i+1].rsByRo, 100*ppmData[i].rsByRo, 100*ppmData[i+1].ppm, 100*ppmData[i].ppm)/100;
      else ppmData[i].ppm; // lowest Rs/Ro or highest PPM data point
    }
  }
  return 0.0;
}

void setup() {
  Serial.begin(9600);
  calibrate(); // should be done in clean conditions
}
 
void loop() {
  unsigned long voltage = VREF*analogRead(AIN)/(ADC_MAX+1);
  
  if (voltage) {
    unsigned long Rs = 100L*(VREF-voltage)/voltage;
    float RsByRo = Rs/(Rs_clean/9.6); // 9.6 from datasheet
    float ppm = getPPM(RsByRo);
    Serial.print("Voltage = ");
    Serial.print(voltage);
    Serial.print("mv; Rs = ");
    Serial.print(Rs);
    Serial.print("; RsByRo = ");
    Serial.print(RsByRo, 2);
    Serial.print("; PPM = ");
    Serial.println(ppm, 0);
  }
  
  delay(1000);
}
